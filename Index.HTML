<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fade Out - Screenplay Editor (Enhanced)</title>
  <style>
    /* Dark Theme & Typography */
    body {
      background-color: #1c0f2e;
      color: white;
      font-family: Courier, monospace;
      margin: 0;
      padding: 0;
    }
    
    body.light {
      background-color: #f8f8f8;
      color: #000000;
    }

    /* App Header */
    .app-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #1c0f2e;
      color: white;
      text-align: center;
      padding: 10px 0;
      z-index: 1000;
      border-bottom: 1px solid #472e63;
      direction: ltr; /* Force LTR for header */
    }
    
    .app-name {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .tagline {
      font-size: 14px;
      opacity: 0.8;
    }

    /* Toolbar */
    .toolbar {
      position: fixed;
      top: 70px; /* Below header */
      left: 0;
      right: 0;
      background-color: #2a1240;
      border-bottom: 2px solid #472e63;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      z-index: 999;
      gap: 5px;
    }

    /* Toolbar Groups */
    .toolbar-group {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }

    /* Editor */
    #editor {
      padding: 130px 20px 20px 20px;
      outline: none;
      white-space: pre-wrap;
      min-height: 80vh;
    }

    /* RTL Fixes */
    body[dir="rtl"] .toolbar {
      direction: rtl;
    }
    
    body[dir="rtl"] .toolbar button {
      float: right;
    }
    
    .rtl {
      direction: rtl;
    }

    /* Element Styles */
    .element { margin: 0; padding: 2px 0; }
    .scene-heading { text-transform: uppercase; margin: 12px 0; text-align: left; font-weight: bold; }
    .action { text-align: left; margin: 12px 0; }
    .character { text-align: center; margin: 30px auto 10px auto; width: 60%; font-weight: bold; text-transform: uppercase; }
    .dialogue { text-align: left; margin: 0 auto 15px auto; width: 70%; }
    .parenthetical { font-style: italic; margin: 0 auto 10px auto; width: 50%; text-align: center; }
    .transition { text-align: right; margin-right: 10%; font-weight: bold; text-transform: uppercase; }
    .active-line { background-color: rgba(255, 215, 0, 0.1); }

    body.light .toolbar {
      background-color: #e3e3e3;
      border-bottom: 2px solid #cccccc;
    }

    .toolbar button {
      background-color: #472e63;
      color: white;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 3px;
      min-width: 100px;
    }

    body.light .toolbar button {
      background-color: #dddddd;
      color: #000000;
    }

    .toolbar button.active {
      background-color: #6b458e;
    }

    /* Character suggestions */
    #character-suggestions {
      position: absolute;
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 3px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 10;
      display: none;
    }

    body.light #character-suggestions {
      background-color: #e3e3e3;
      border: 1px solid #000000;
    }

    .character-suggestion-item {
      padding: 5px 10px;
      cursor: pointer;
    }

    .character-suggestion-item:hover {
      background-color: #472e63;
    }

    body.light .character-suggestion-item:hover {
      background-color: #cccccc;
    }

    /* Notification */
    #notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: gold;
      color: #1c0f2e;
      padding: 10px 20px;
      border-radius: 3px;
      display: none;
      z-index: 100;
    }

    /* Modals */
    .modal-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 1001;
      justify-content: center;
      align-items: center;
    }

    .modal {
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 5px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
    }

    body.light .modal {
      background-color: #f8f8f8;
      border: 1px solid #000000;
    }

    .modal h2 {
      margin-top: 0;
      color: gold;
    }

    body.light .modal h2 {
      color: #000000;
    }

    .modal input {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border-radius: 3px;
      border: 1px solid gold;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
    }

    body.light .modal input {
      border: 1px solid #000000;
      background-color: white;
      color: #000000;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .cancel-btn {
      background: none;
      border: 1px solid gold;
      color: gold;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
    }

    .confirm-btn {
      background-color: gold;
      color: #1c0f2e;
      border: none;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
    }

    body.light .cancel-btn {
      border: 1px solid #000000;
      color: #000000;
    }

    body.light .confirm-btn {
      background-color: #000000;
      color: white;
    }

    /* Feedback box */
    #feedback-box {
      display: none;
      margin: 10px;
      padding: 15px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    #feedback-text {
      width: 100%;
      height: 80px;
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 3px;
      border: 1px solid gold;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
    }

    body.light #feedback-text {
      border: 1px solid #000000;
      background-color: white;
      color: #000000;
    }

    #send-feedback-btn {
      background-color: gold;
      color: #1c0f2e;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 3px;
    }

    body.light #send-feedback-btn {
      background-color: #000000;
      color: white;
    }
    
    /* Transition dropdown */
    #transition-dropdown {
      position: absolute;
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 3px;
      max-height: 250px;
      width: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    
    .transition-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .transition-item:hover {
      background-color: #472e63;
    }
    
    body.light #transition-dropdown {
      background-color: #f8f8f8;
      border: 1px solid #000;
    }
    
    body.light .transition-item:hover {
      background-color: #ddd;
    }
  </style>
</head>
<body class="dark-mode">
  <!-- Header -->
  <div class="app-header">
    <div class="app-name">Fade Out</div>
    <div class="tagline">Write. Rewrite. Fade Out.</div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <div>
      <button id="scene-heading-btn" class="element-button active" data-type="scene-heading">SCENE HEADING</button>
      <button id="action-btn" class="element-button" data-type="action">ACTION</button>
      <button id="character-btn" class="element-button" data-type="character">CHARACTER</button>
      <button id="dialogue-btn" class="element-button" data-type="dialogue">DIALOGUE</button>
      <button id="parenthetical-btn" class="element-button" data-type="parenthetical">PARENTHETICAL</button>
      <button id="transition-btn" class="element-button" data-type="transition">TRANSITION</button>
    </div>
    <div>
      <button id="save-btn">SAVE</button>
      <button id="load-btn">LOAD</button>
      <button id="export-btn">EXPORT</button>
      <button id="theme-toggle">LIGHT</button>
      <button id="rtl-toggle">ARABIC</button>
      <button id="feedback-btn">FEEDBACK</button>
      <button id="share-btn">SHARE</button>
    </div>
  </div>

  <!-- Editor -->
  <div id="editor" class="ltr" contenteditable="true" spellcheck="true" data-current-element="scene-heading">
    <div class="element scene-heading" id="element-1">INT. COFFEE SHOP - DAY</div>
    <div class="element action" id="element-2">A crowded coffee shop buzzes with energy. ALEX (30s, creative type) types furiously on their laptop.</div>
    <div class="element character" id="element-3">ALEX</div>
    <div class="element parenthetical" id="element-4">(to self)</div>
    <div class="element dialogue" id="element-5">This screenplay format is working perfectly.</div>
    <div class="element action" id="element-6">A BARISTA approaches with a fresh cup of coffee.</div>
    <div class="element character" id="element-7">BARISTA</div>
    <div class="element dialogue" id="element-8">Here's your inspiration juice. Need anything else?</div>
    <div class="element character" id="element-9">ALEX</div>
    <div class="element dialogue" id="element-10">Just what I needed. Thanks.</div>
  </div>

  <!-- Character suggestions -->
  <div id="character-suggestions"></div>
  
  <!-- Transition dropdown -->
  <div id="transition-dropdown">
    <div class="transition-item" data-text="CUT TO:">CUT TO:</div>
    <div class="transition-item" data-text="FADE IN:">FADE IN:</div>
    <div class="transition-item" data-text="FADE OUT:">FADE OUT:</div>
    <div class="transition-item" data-text="FADE TO:">FADE TO:</div>
    <div class="transition-item" data-text="DISSOLVE TO:">DISSOLVE TO:</div>
    <div class="transition-item" data-text="BACK TO:">BACK TO:</div>
    <div class="transition-item" data-text="MATCH CUT TO:">MATCH CUT TO:</div>
    <div class="transition-item" data-text="JUMP CUT TO:">JUMP CUT TO:</div>
  </div>
  
  <!-- Notification -->
  <div id="notification">Notification Message</div>
  
  <!-- Feedback box -->
  <div id="feedback-box">
    <textarea id="feedback-text" placeholder="Enter your feedback here..."></textarea>
    <button id="send-feedback-btn">Send Feedback</button>
  </div>
  
  <!-- Save Modal -->
  <div class="modal-container" id="save-modal-container">
    <div class="modal">
      <h2>Save Script</h2>
      <input type="text" id="script-title" placeholder="Script Title">
      <div class="modal-buttons">
        <button class="cancel-btn" id="save-cancel">Cancel</button>
        <button class="confirm-btn" id="save-confirm">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Load Modal -->
  <div class="modal-container" id="load-modal-container">
    <div class="modal">
      <h2>Load Script</h2>
      <div id="saved-scripts-list" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>
      <div class="modal-buttons">
        <button class="cancel-btn" id="load-cancel">Cancel</button>
        <button class="confirm-btn" id="load-confirm">Load</button>
      </div>
    </div>
  </div>
  
  <!-- Share Modal -->
  <div class="modal-container" id="share-modal-container">
    <div class="modal">
      <h2>Share Script</h2>
      <input type="text" id="share-link" readonly placeholder="Share link will appear here">
      <div class="modal-buttons">
        <button class="cancel-btn" id="share-cancel">Close</button>
        <button class="confirm-btn" id="copy-link">Copy Link</button>
      </div>
    </div>
  </div>

  <script>
// Arabic translations
const arabicLabels = {
  'SCENE HEADING': 'العنوان الرئيسي',
  'ACTION': 'الفعل',
  'CHARACTER': 'الشخصية',
  'DIALOGUE': 'الحوار',
  'PARENTHETICAL': 'توضيح',
  'TRANSITION': 'الانتقال',
  'SAVE': 'حفظ',
  'LOAD': 'تحميل',
  'EXPORT': 'تصدير',
  'FEEDBACK': 'تعليق',
  'ARABIC': 'English',
  'ENGLISH': 'عربي',
  'LIGHT': 'مضيء',
  'DARK': 'مظلم'
};

// Global state
let currentElement = 'scene-heading';
let isRtlMode = false;
let scriptCharacters = new Set(['ALEX', 'BARISTA']);
let commonTransitions = [
  'CUT TO:',
  'FADE IN:',
  'FADE OUT:',
  'FADE TO BLACK',
  'DISSOLVE TO:',
  'SMASH CUT TO:',
  'JUMP CUT TO:',
  'MATCH CUT TO:',
  'IRIS IN:',
  'IRIS OUT:',
  'WIPE TO:',
  'CROSSFADE:',
  'FLASH CUT TO:',
  'INTERCUT WITH:',
  'FREEZE FRAME.',
  'THE END'
];

// DOM references
let editor, notification;

// Initialize the editor
document.addEventListener('DOMContentLoaded', function() {
  // Get DOM elements
  editor = document.getElementById('editor');
  notification = document.getElementById('notification');
  
  // Set up event listeners
  setupListeners();
  
  // Extract characters from existing content
  extractCharacters();
  
  // Place cursor at the beginning
  const sceneHeading = document.querySelector('.scene-heading');
  if (sceneHeading) setCaretToEnd(sceneHeading);
});

function setupListeners() {
  // Element type buttons
  document.querySelectorAll('.element-button').forEach(btn => {
    btn.addEventListener('click', function() {
      // Set active element type
      currentElement = this.dataset.type;
      
      // Update active button styling
      document.querySelectorAll('.element-button').forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      // Insert new element
      addNewElement(currentElement);
    });
  });
  
  // Action buttons
  document.getElementById('save-btn')?.addEventListener('click', saveScript);
  document.getElementById('load-btn')?.addEventListener('click', loadScript);
  document.getElementById('export-btn')?.addEventListener('click', exportScript);
  document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);
  document.getElementById('rtl-toggle')?.addEventListener('click', toggleDirection);
  document.getElementById('feedback-btn')?.addEventListener('click', toggleFeedback);
  document.getElementById('share-btn')?.addEventListener('click', shareScript);
  
  // Modal buttons
  document.getElementById('save-cancel')?.addEventListener('click', () => {
    document.getElementById('save-modal-container').style.display = 'none';
  });
  document.getElementById('save-confirm')?.addEventListener('click', () => {
    const title = document.getElementById('script-title').value.trim() || 'Untitled Script';
    const content = editor.innerHTML;
    
    // Save to localStorage
    const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
    scripts[title] = {
      content,
      characters: Array.from(scriptCharacters),
      timestamp: Date.now()
    };
    localStorage.setItem('scripts', JSON.stringify(scripts));
    
    // Hide modal and show notification
    document.getElementById('save-modal-container').style.display = 'none';
    showNotification(\`Script "\${title}" saved successfully\`);
  });
  
  document.getElementById('load-cancel')?.addEventListener('click', () => {
    document.getElementById('load-modal-container').style.display = 'none';
  });
  document.getElementById('load-confirm')?.addEventListener('click', () => {
    const selected = document.querySelector('.saved-script-item.selected');
    if (!selected) {
      showNotification('Please select a script to load');
      return;
    }
    
    const scriptName = selected.getAttribute('data-name');
    const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
    
    if (scripts[scriptName]) {
      // Create a temporary div to safely parse the content
      const tempDiv = document.createElement('div');
      // Use DOMParser instead of innerHTML for safer parsing
      const parser = new DOMParser();
      const doc = parser.parseFromString(scripts[scriptName].content, 'text/html');
      tempDiv.append(...doc.body.childNodes);
      
      // Only copy the elements we expect in our screenplay editor
      const safeContent = document.createDocumentFragment();
      tempDiv.querySelectorAll('.element').forEach(element => {
        // Only copy expected attributes to prevent script injection
        const safeElement = document.createElement('div');
        safeElement.className = element.className;
        safeElement.dataset.type = element.dataset.type;
        safeElement.contentEditable = 'true';
        safeElement.textContent = element.textContent; // Use textContent instead of innerHTML
        safeElement.style.textAlign = element.style.textAlign;
        
        if (isRtlMode) {
          safeElement.setAttribute('dir', 'rtl');
          safeElement.setAttribute('lang', 'ar');
        }
        
        safeContent.appendChild(safeElement);
      });
      
      // Clear the editor and append the sanitized content
      editor.innerHTML = '';
      editor.appendChild(safeContent);
      
      // Restore characters
      if (scripts[scriptName].characters) {
        scriptCharacters = new Set(scripts[scriptName].characters);
      }
      
      document.getElementById('load-modal-container').style.display = 'none';
      showNotification(\`Script "\${scriptName}" loaded successfully\`);
    }
  });
  
  document.getElementById('share-cancel')?.addEventListener('click', () => {
    document.getElementById('share-modal-container').style.display = 'none';
  });
  document.getElementById('copy-link')?.addEventListener('click', () => {
    const link = document.getElementById('share-link');
    link.select();
    document.execCommand('copy');
    showNotification('Link copied to clipboard');
  });
  
  document.getElementById('send-feedback-btn')?.addEventListener('click', () => {
    const feedbackText = document.getElementById('feedback-text')?.value.trim();
    if (!feedbackText) {
      showNotification('Please enter your feedback');
      return;
    }
    
    // In a real app, this would send feedback to a server
    showNotification('Thank you for your feedback!');
    if (document.getElementById('feedback-text')) {
      document.getElementById('feedback-text').value = '';
    }
    document.getElementById('feedback-box').style.display = 'none';
  });
  
  // Editor events
  if (editor) {
    // Handle Enter key to add new elements
    editor.addEventListener('keydown', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        handleEnterKey();
      } else if (e.key === 'Tab') {
        e.preventDefault();
        cycleElementType();
      }
    });
    
    // Handle clicks to set active element
    editor.addEventListener('click', function(e) {
      const target = e.target;
      if (target === editor) return;
      
      // Find closest screenplay element
      let element = target;
      while (element && element !== editor && !element.classList.contains('element')) {
        element = element.parentNode;
      }
      
      if (element && element !== editor) {
        // Set active line
        const elements = document.querySelectorAll('#editor .element');
        elements.forEach(el => el.classList.remove('active-line'));
        element.classList.add('active-line');
        
        // Update current element type
        currentElement = element.dataset.type;
        
        // Update button styles
        updateActiveButton();
      }
    });
  }
}

// Add a new screenplay element
function addNewElement(type, text = '') {
  if (!editor) return;
  
  // Create new element
  const div = document.createElement('div');
  div.className = \`element \${type}\`;
  div.id = \`element-\${Date.now()}\`;
  
  // Set RTL direction if needed
  if (isRtlMode) {
    div.setAttribute('dir', 'rtl');
    div.setAttribute('lang', 'ar');
    
    // Set proper alignment
    if (type === 'scene-heading' || type === 'action') {
      div.style.textAlign = 'right';
    } else if (type === 'transition') {
      div.style.textAlign = 'left';
    }
  } else {
    if (type === 'transition') {
      div.style.textAlign = 'right';
    }
  }
  
  // Default content for specific types
  if (type === 'scene-heading' && !text) {
    div.textContent = isRtlMode ? '.INT ' : 'INT. ';
  } else if (type === 'parenthetical' && !text) {
    div.textContent = '()';
  } else if (text) {
    div.textContent = text;
  } else {
    div.innerHTML = '&nbsp;';
  }
  
  // Remove active line from other elements
  const activeElement = document.querySelector('.active-line');
  if (activeElement) {
    activeElement.classList.remove('active-line');
    activeElement.after(div);
  } else {
    editor.appendChild(div);
  }
  
  // Add active line to new element
  div.classList.add('active-line');
  
  // Set cursor position
  setCaretToEnd(div);
  
  // Add input handler for character elements to show suggestions
  if (type === 'character') {
    div.addEventListener('input', function() {
      const text = this.textContent?.trim().toUpperCase() || '';
      if (text.length > 0) {
        showCharacterSuggestions(text, this);
      } else {
        hideCharacterSuggestions();
      }
    });
  }
  
  // Add transition dropdown toggle for transition elements
  if (type === 'transition') {
    div.addEventListener('click', function(e) {
      showTransitionDropdown(this);
    });
  }
}

// Handle Enter key presses
function handleEnterKey() {
  const activeElement = document.querySelector('.active-line');
  if (!activeElement) return;
  
  // Get current type
  const type = activeElement.dataset.type;
  
  // Determine next type based on screenplay format rules
  let nextType = 'action'; // Default
  
  if (type === 'scene-heading') nextType = 'action';
  else if (type === 'action') nextType = 'action';
  else if (type === 'character') {
    const text = activeElement.textContent.trim();
    if (text) {
      nextType = 'dialogue';
      // Add character to our list
      scriptCharacters.add(text);
    } else {
      nextType = 'character';
    }
  }
  else if (type === 'dialogue') nextType = 'character';
  else if (type === 'parenthetical') nextType = 'dialogue';
  else if (type === 'transition') {
    // Always create a scene heading after a transition
    nextType = 'scene-heading';
  }
  
  // Create new element
  addNewElement(nextType);
  
  // Update current element type
  currentElement = nextType;
  
  // Update button styles
  updateActiveButton();
}

// Cycle through element types with Tab key
function cycleElementType() {
  const activeElement = document.querySelector('.active-line');
  if (!activeElement) return;
  
  // Determine next type
  const type = activeElement.dataset.type;
  let nextType = 'action';
  
  if (type === 'scene-heading') nextType = 'action';
  else if (type === 'action') nextType = 'character';
  else if (type === 'character') nextType = 'parenthetical';
  else if (type === 'parenthetical') nextType = 'dialogue';
  else if (type === 'dialogue') nextType = 'character';
  else if (type === 'transition') nextType = 'scene-heading';
  
  // Update element class and dataset
  activeElement.classList.remove(type);
  activeElement.classList.add(nextType);
  activeElement.dataset.type = nextType;
  
  // Special formatting for specific types
  if (nextType === 'scene-heading' && (activeElement.textContent.trim() === '' || activeElement.textContent === '\\u00A0')) {
    activeElement.textContent = isRtlMode ? '.INT ' : 'INT. ';
  } else if (nextType === 'parenthetical' && (activeElement.textContent.trim() === '' || activeElement.textContent === '\\u00A0')) {
    activeElement.textContent = '()';
  }
  
  // Update RTL settings
  if (isRtlMode) {
    if (nextType === 'scene-heading' || nextType === 'action') {
      activeElement.style.textAlign = 'right';
    } else if (nextType === 'transition') {
      activeElement.style.textAlign = 'left';
    } else {
      activeElement.style.textAlign = '';
    }
  } else {
    if (nextType === 'transition') {
      activeElement.style.textAlign = 'right';
    } else {
      activeElement.style.textAlign = '';
    }
  }
  
  // Update current element type
  currentElement = nextType;
  
  // Update button styles
  updateActiveButton();
}

// Update active button in toolbar
function updateActiveButton() {
  document.querySelectorAll('.element-button').forEach(btn => {
    btn.classList.remove('active');
  });
  
  const activeButton = document.querySelector(\`.element-button[data-type="\${currentElement}"]\`);
  if (activeButton) {
    activeButton.classList.add('active');
  }
}

// Place cursor at the end of an element
function setCaretToEnd(el) {
  if (!el) return;
  
  el.focus();
  const range = document.createRange();
  if (el.firstChild) {
    range.setStart(el.firstChild, el.firstChild.textContent.length);
  } else {
    range.setStart(el, 0);
  }
  range.collapse(true);
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
}

// Extract character names from elements
function extractCharacters() {
  if (!editor) return;
  
  const characterElements = editor.querySelectorAll('.character');
  characterElements.forEach(el => {
    const character = el.textContent?.trim();
    if (character) {
      scriptCharacters.add(character);
    }
  });
}

// Save script
function saveScript() {
  const saveModal = document.getElementById('save-modal-container');
  if (saveModal) {
    saveModal.style.display = 'flex';
    const scriptTitle = document.getElementById('script-title');
    if (scriptTitle) {
      scriptTitle.value = '';
      scriptTitle.focus();
    }
  }
}

// Load script
function loadScript() {
  const loadModal = document.getElementById('load-modal-container');
  const scriptsList = document.getElementById('saved-scripts-list');
  
  if (loadModal && scriptsList) {
    // Clear previous list
    scriptsList.innerHTML = '';
    
    // Get saved scripts
    const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
    
    if (Object.keys(scripts).length === 0) {
      scriptsList.innerHTML = '<div style="padding: 10px;">No saved scripts found</div>';
    } else {
      // Sort by date (newest first)
      const sortedScripts = Object.entries(scripts).sort((a, b) => b[1].timestamp - a[1].timestamp);
      
      // Create list items
      sortedScripts.forEach(([name, data]) => {
        const item = document.createElement('div');
        item.className = 'saved-script-item';
        item.setAttribute('data-name', name);
        // Create elements instead of using innerHTML to prevent XSS
        const nameElement = document.createElement('strong');
        nameElement.textContent = name;
        
        const dateElement = document.createElement('small');
        dateElement.textContent = new Date(data.timestamp).toLocaleString();
        
        // Clear and append the new elements
        item.appendChild(nameElement);
        item.appendChild(document.createElement('br'));
        item.appendChild(dateElement);
        item.style.padding = '8px';
        item.style.margin = '5px 0';
        item.style.cursor = 'pointer';
        item.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
        
        // Select on click
        item.addEventListener('click', function() {
          document.querySelectorAll('.saved-script-item').forEach(el => {
            el.classList.remove('selected');
            el.style.backgroundColor = '';
          });
          this.classList.add('selected');
          this.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
        });
        
        scriptsList.appendChild(item);
      });
    }
    
    // Show modal
    loadModal.style.display = 'flex';
  }
}

// Export script as HTML
function exportScript() {
  const content = editor.innerHTML;
  const title = prompt('Enter script title for export:', 'My Screenplay');
  
  if (!title) return;
  
  const exportHtml = \`
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>\${title}</title>
  <style>
    body {
      font-family: Courier, monospace;
      line-height: 1.5;
      margin: 40px;
    }
    .scene-heading {
      text-transform: uppercase;
      font-weight: bold;
      margin-top: 2em;
    }
    .action { margin: 1em 0; }
    .character {
      text-transform: uppercase;
      margin-left: 200px;
      margin-bottom: 0;
    }
    .parenthetical {
      margin-left: 160px;
      margin-bottom: 0;
    }
    .dialogue {
      margin-left: 100px;
      margin-right: 100px;
      margin-bottom: 1em;
    }
    .transition {
      text-align: right;
      text-transform: uppercase;
      margin: 2em 0;
    }
  </style>
</head>
<body>
  <h1>\${title}</h1>
  <div id="screenplay">
    \${content}
  </div>
</body>
</html>\`;
  
  // Create a blob link
  const blob = new Blob([exportHtml], {type: 'text/html'});
  const url = URL.createObjectURL(blob);
  
  // Create a download link
  const a = document.createElement('a');
  a.href = url;
  a.download = \`\${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.html\`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  
  // Show notification
  showNotification('Screenplay exported successfully!');
}

// Toggle theme
function toggleTheme() {
  const themeToggle = document.getElementById('theme-toggle');
  const body = document.body;
  
  body.classList.toggle('light');
  
  if (body.classList.contains('light')) {
    themeToggle.textContent = isRtlMode ? arabicLabels['DARK'] : 'DARK';
  } else {
    themeToggle.textContent = isRtlMode ? arabicLabels['LIGHT'] : 'LIGHT';
  }
}

// Toggle direction (RTL for Arabic)
function toggleDirection() {
  const dirToggle = document.getElementById('rtl-toggle');
  const elements = document.querySelectorAll('#editor .element');
  
  isRtlMode = !isRtlMode;
  
  if (isRtlMode) {
    // Switch to RTL
    editor.classList.add('rtl');
    editor.classList.remove('ltr');
    dirToggle.textContent = arabicLabels['ARABIC']; // "English" in Arabic
    
    // Update all elements
    elements.forEach(el => {
      el.setAttribute('dir', 'rtl');
      el.setAttribute('lang', 'ar');
    });
    
    // Update toolbar labels
    updateToolbarLabels(true);
  } else {
    // Switch to LTR
    editor.classList.remove('rtl');
    editor.classList.add('ltr');
    dirToggle.textContent = 'ARABIC';
    
    // Update all elements
    elements.forEach(el => {
      el.removeAttribute('dir');
      el.removeAttribute('lang');
    });
    
    // Update toolbar labels
    updateToolbarLabels(false);
  }
}

// Update toolbar labels based on language
function updateToolbarLabels(useArabic) {
  if (useArabic) {
    document.querySelectorAll('.element-button').forEach(btn => {
      const type = btn.dataset.type;
      btn.textContent = arabicLabels[btn.textContent];
    });
    
    document.getElementById('save-btn').textContent = arabicLabels['SAVE'];
    document.getElementById('load-btn').textContent = arabicLabels['LOAD'];
    document.getElementById('export-btn').textContent = arabicLabels['EXPORT'];
    document.getElementById('feedback-btn').textContent = arabicLabels['FEEDBACK'];
    
    // Toggle button needs special handling
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.textContent = document.body.classList.contains('light') ? arabicLabels['DARK'] : arabicLabels['LIGHT'];
  } else {
    document.querySelectorAll('.element-button').forEach(btn => {
      const type = btn.dataset.type;
      btn.textContent = type.replace('-', ' ').toUpperCase();
    });
    
    document.getElementById('save-btn').textContent = 'SAVE';
    document.getElementById('load-btn').textContent = 'LOAD';
    document.getElementById('export-btn').textContent = 'EXPORT';
    document.getElementById('feedback-btn').textContent = 'FEEDBACK';
    
    // Toggle button needs special handling
    const themeToggle = document.getElementById('theme-toggle');
    themeToggle.textContent = document.body.classList.contains('light') ? 'DARK' : 'LIGHT';
  }
}

// Toggle feedback box
function toggleFeedback() {
  const feedbackBox = document.getElementById('feedback-box');
  if (feedbackBox) {
    feedbackBox.style.display = feedbackBox.style.display === 'none' || !feedbackBox.style.display ? 'block' : 'none';
    if (feedbackBox.style.display === 'block') {
      document.getElementById('feedback-text').focus();
    }
  }
}

// Show character suggestions dropdown
function showCharacterSuggestions(text, element) {
  if (!text) return;
  
  const characterSuggestions = document.getElementById('character-suggestions');
  if (!characterSuggestions) return;
  
  // Get matching characters
  const matches = Array.from(scriptCharacters).filter(char => 
    char.includes(text) && char !== text
  );
  
  if (matches.length > 0) {
    // Clear previous suggestions
    characterSuggestions.innerHTML = '';
    
    // Position the dropdown
    const rect = element.getBoundingClientRect();
    characterSuggestions.style.top = \`\${rect.bottom + window.scrollY}px\`;
    characterSuggestions.style.left = \`\${rect.left + window.scrollX}px\`;
    characterSuggestions.style.display = 'block';
    
    // Add suggestion items
    matches.forEach(char => {
      const item = document.createElement('div');
      item.className = 'character-suggestion-item';
      item.textContent = char;
      item.addEventListener('click', () => {
        element.textContent = char;
        hideCharacterSuggestions();
        
        // After selecting a character, create a dialogue element
        addNewElement('dialogue');
      });
      characterSuggestions.appendChild(item);
    });
  } else {
    hideCharacterSuggestions();
  }
}

// Hide character suggestions
function hideCharacterSuggestions() {
  const characterSuggestions = document.getElementById('character-suggestions');
  if (characterSuggestions) {
    characterSuggestions.style.display = 'none';
  }
}

// Show transition dropdown
function showTransitionDropdown(element) {
  const dropdown = document.getElementById('transition-dropdown');
  if (!dropdown) return;
  
  // Position the dropdown
  const rect = element.getBoundingClientRect();
  dropdown.style.top = \`\${rect.bottom + window.scrollY}px\`;
  dropdown.style.left = \`\${rect.left + window.scrollX}px\`;
  
  // Clear existing items and rebuild with event listeners
  dropdown.innerHTML = '';
  
  // Add each transition item
  commonTransitions.forEach(transitionText => {
    const oldItem = document.createElement('div');
    oldItem.className = 'transition-item';
    oldItem.textContent = transitionText;
    oldItem.dataset.text = transitionText;
    dropdown.appendChild(oldItem);
    
    // Add new event listener
    oldItem.addEventListener('click', () => {
      element.textContent = oldItem.textContent;
      hideTransitionDropdown();
      setCaretToEnd(element);
    });
  });
  
  // Show the dropdown
  dropdown.style.display = 'block';
  
  // Add a click handler to the document to close the dropdown when clicking outside
  setTimeout(() => {
    document.addEventListener('click', hideTransitionDropdownOnClickOutside);
  }, 10);
}

// Hide transition dropdown
function hideTransitionDropdown() {
  const dropdown = document.getElementById('transition-dropdown');
  if (dropdown) {
    dropdown.style.display = 'none';
  }
  
  // Remove the document click handler
  document.removeEventListener('click', hideTransitionDropdownOnClickOutside);
}

// Hide dropdown when clicking outside
function hideTransitionDropdownOnClickOutside(e) {
  const dropdown = document.getElementById('transition-dropdown');
  const clickedOnDropdown = dropdown.contains(e.target);
  
  if (!clickedOnDropdown) {
    hideTransitionDropdown();
  }
}

// Share script
function shareScript() {
  const shareModal = document.getElementById('share-modal-container');
  const shareLink = document.getElementById('share-link');
  
  if (shareModal && shareLink) {
    // Generate a unique ID for the script
    const scriptId = Math.random().toString(36).substring(2, 15);
    
    // In a real app, this would save to a database and generate a real share URL
    // For this demo, we'll just create a fake URL
    const url = window.location.href.split('?')[0] + '?script=' + scriptId;
    
    shareLink.value = url;
    shareModal.style.display = 'flex';
  }
}

// Show notification
function showNotification(message) {
  if (!notification) return;
  
  notification.textContent = message;
  notification.style.display = 'block';
  
  // Hide after 2 seconds
  setTimeout(() => {
    notification.style.display = 'none';
  }, 2000);
}
  </script>
</body>
</html>
