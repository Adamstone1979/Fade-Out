<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fade Out - Screenplay Editor</title>
  <style>
    /* Dark Theme & Typography */
    body {
      background-color: #1c0f2e;
      color: white;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
    }
    
    body.light {
      background-color: #f8f8f8;
      color: #000000;
    }

    /* App Header */
    .app-header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #1c0f2e;
      color: white;
      text-align: center;
      padding: 10px 0;
      z-index: 1000;
      border-bottom: 1px solid #472e63;
      direction: ltr; /* Force LTR for header */
    }
    
    .app-name {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    
    .tagline {
      font-size: 14px;
      opacity: 0.8;
    }

    /* Toolbar */
    .toolbar {
      position: fixed;
      top: 70px; /* Below header */
      left: 0;
      right: 0;
      background-color: #2a1240;
      border-bottom: 2px solid #472e63;
      padding: 10px;
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      z-index: 999;
      gap: 5px;
    }

    /* Editor */
    #editor {
      padding: 130px 20px 20px 20px;
      outline: none;
      white-space: pre-wrap;
      min-height: 80vh;
    }

    /* RTL Fixes */
    body[dir="rtl"] .toolbar {
      direction: rtl;
    }
    
    body[dir="rtl"] .toolbar button {
      float: right;
    }
    
    .rtl {
      direction: rtl;
    }

    /* Element Styles */
    .element { margin: 0; padding: 2px 0; }
    .scene-heading { text-transform: uppercase; margin: 12px 0; text-align: left; font-weight: bold; }
    .action { text-align: left; margin: 12px 0; }
    .character { text-align: center; margin: 30px auto 10px auto; width: 60%; font-weight: bold; text-transform: uppercase; }
    .dialogue { text-align: left; margin: 0 auto 15px auto; width: 70%; }
    .parenthetical { font-style: italic; margin: 0 auto 10px auto; width: 50%; text-align: center; }
    .transition { text-align: right; margin-right: 10%; font-weight: bold; text-transform: uppercase; }
    .active-line { background-color: rgba(255, 215, 0, 0.1); }

    body.light .toolbar {
      background-color: #e3e3e3;
      border-bottom: 2px solid #cccccc;
    }

    .toolbar button {
      background-color: #472e63;
      color: white;
      border: none;
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 3px;
      min-width: 100px;
    }

    body.light .toolbar button {
      background-color: #dddddd;
      color: #000000;
    }

    .toolbar button.active {
      background-color: #6b458e;
    }

    /* Character suggestions */
    #character-suggestions {
      position: absolute;
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 3px;
      max-height: 150px;
      overflow-y: auto;
      z-index: 10;
      display: none;
    }

    body.light #character-suggestions {
      background-color: #e3e3e3;
      border: 1px solid #000000;
    }

    .character-suggestion-item {
      padding: 5px 10px;
      cursor: pointer;
    }

    .character-suggestion-item:hover {
      background-color: #472e63;
    }

    body.light .character-suggestion-item:hover {
      background-color: #cccccc;
    }

    /* Notification */
    #notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: gold;
      color: #1c0f2e;
      padding: 10px 20px;
      border-radius: 3px;
      display: none;
      z-index: 100;
    }

    /* Modals */
    .modal-container {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 1001;
      justify-content: center;
      align-items: center;
    }

    .modal {
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 5px;
      padding: 20px;
      width: 90%;
      max-width: 500px;
    }

    body.light .modal {
      background-color: #f8f8f8;
      border: 1px solid #000000;
    }

    .modal h2 {
      margin-top: 0;
      color: gold;
    }

    body.light .modal h2 {
      color: #000000;
    }

    .modal input {
      width: 100%;
      padding: 8px;
      margin: 10px 0;
      border-radius: 3px;
      border: 1px solid gold;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
    }

    body.light .modal input {
      border: 1px solid #000000;
      background-color: white;
      color: #000000;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .cancel-btn {
      background: none;
      border: 1px solid gold;
      color: gold;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
    }

    .confirm-btn {
      background-color: gold;
      color: #1c0f2e;
      border: none;
      padding: 8px 16px;
      border-radius: 3px;
      cursor: pointer;
    }

    body.light .cancel-btn {
      border: 1px solid #000000;
      color: #000000;
    }

    body.light .confirm-btn {
      background-color: #000000;
      color: white;
    }

    /* Feedback box */
    #feedback-box {
      display: none;
      margin: 10px;
      padding: 15px;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    #feedback-text {
      width: 100%;
      height: 80px;
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 3px;
      border: 1px solid gold;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
    }

    body.light #feedback-text {
      border: 1px solid #000000;
      background-color: white;
      color: #000000;
    }

    #send-feedback-btn {
      background-color: gold;
      color: #1c0f2e;
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 3px;
    }

    body.light #send-feedback-btn {
      background-color: #000000;
      color: white;
    }
    
    /* Transition dropdown */
    #transition-dropdown {
      position: absolute;
      background-color: #2a1240;
      border: 1px solid gold;
      border-radius: 3px;
      max-height: 250px;
      width: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    
    .transition-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 215, 0, 0.3);
    }
    
    .transition-item:hover {
      background-color: #472e63;
    }
    
    body.light #transition-dropdown {
      background-color: #f8f8f8;
      border: 1px solid #000;
    }
    
    body.light .transition-item:hover {
      background-color: #ddd;
    }

    /* Selected script styling */
    .saved-script-item.selected {
      background-color: rgba(255, 215, 0, 0.2);
    }
    
    /* Format Modal Styling */
    .format-option {
      margin-bottom: 15px;
      padding: 15px;
      border: 1px solid gold;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .format-option:hover {
      background-color: rgba(255, 215, 0, 0.1);
    }
    
    body.light .format-option {
      border-color: #000000;
    }
    
    body.light .format-option:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    
    .format-option h3 {
      margin-top: 0;
      color: gold;
    }
    
    body.light .format-option h3 {
      color: #000000;
    }
    
    .format-option p {
      margin-bottom: 0;
      font-size: 14px;
      opacity: 0.8;
    }
  </style>
</head>
<body class="dark-mode">
  <!-- Header -->
  <div class="app-header">
    <div class="app-name">Fade Out</div>
    <div class="tagline">Write. Rewrite. Fade Out.</div>
  </div>

  <!-- Toolbar -->
  <div class="toolbar">
    <div>
      <button id="scene-heading-btn" class="element-button active" data-type="scene-heading">SCENE HEADING</button>
      <button id="action-btn" class="element-button" data-type="action">ACTION</button>
      <button id="character-btn" class="element-button" data-type="character">CHARACTER</button>
      <button id="dialogue-btn" class="element-button" data-type="dialogue">DIALOGUE</button>
      <button id="parenthetical-btn" class="element-button" data-type="parenthetical">PARENTHETICAL</button>
      <button id="transition-btn" class="element-button" data-type="transition">TRANSITION</button>
    </div>
    <div>
      <button id="save-btn">SAVE</button>
      <button id="load-btn">LOAD</button>
      <button id="export-btn">EXPORT</button>
      <button id="theme-toggle">LIGHT</button>
      <button id="rtl-toggle">ARABIC</button>
      <button id="feedback-btn">FEEDBACK</button>
      <button id="share-btn">SHARE</button>
    </div>
  </div>

  <!-- Editor -->
  <div id="editor" class="ltr" contenteditable="true" spellcheck="true" data-current-element="scene-heading">
    <div class="element scene-heading" id="element-1">INT. COFFEE SHOP - DAY</div>
    <div class="element action" id="element-2">A crowded coffee shop buzzes with energy. ALEX (30s, creative type) types furiously on their laptop.</div>
    <div class="element character" id="element-3">ALEX</div>
    <div class="element parenthetical" id="element-4">(to self)</div>
    <div class="element dialogue" id="element-5">This screenplay format is working perfectly.</div>
    <div class="element action" id="element-6">A BARISTA approaches with a fresh cup of coffee.</div>
    <div class="element character" id="element-7">BARISTA</div>
    <div class="element dialogue" id="element-8">Here's your inspiration juice. Need anything else?</div>
    <div class="element character" id="element-9">ALEX</div>
    <div class="element dialogue" id="element-10">Just what I needed. Thanks.</div>
  </div>

  <!-- Character suggestions -->
  <div id="character-suggestions"></div>
  
  <!-- Transition dropdown -->
  <div id="transition-dropdown">
    <div class="transition-item" data-text="CUT TO:">CUT TO:</div>
    <div class="transition-item" data-text="FADE IN:">FADE IN:</div>
    <div class="transition-item" data-text="FADE OUT:">FADE OUT:</div>
    <div class="transition-item" data-text="FADE TO:">FADE TO:</div>
    <div class="transition-item" data-text="DISSOLVE TO:">DISSOLVE TO:</div>
    <div class="transition-item" data-text="BACK TO:">BACK TO:</div>
    <div class="transition-item" data-text="MATCH CUT TO:">MATCH CUT TO:</div>
    <div class="transition-item" data-text="JUMP CUT TO:">JUMP CUT TO:</div>
  </div>
  
  <!-- Notification -->
  <div id="notification">Notification Message</div>
  
  <!-- Feedback box -->
  <div id="feedback-box">
    <textarea id="feedback-text" placeholder="Enter your feedback here..."></textarea>
    <button id="send-feedback-btn">Send Feedback</button>
  </div>
  
  <!-- Save Modal -->
  <div class="modal-container" id="save-modal-container">
    <div class="modal">
      <h2>Save Script</h2>
      <input type="text" id="script-title" placeholder="Script Title">
      <div class="modal-buttons">
        <button class="cancel-btn" id="save-cancel">Cancel</button>
        <button class="confirm-btn" id="save-confirm">Save</button>
      </div>
    </div>
  </div>
  
  <!-- Load Modal -->
  <div class="modal-container" id="load-modal-container">
    <div class="modal">
      <h2>Load Script</h2>
      <div id="saved-scripts-list" style="max-height: 200px; overflow-y: auto; margin: 10px 0;"></div>
      <div class="modal-buttons">
        <button class="cancel-btn" id="load-cancel">Cancel</button>
        <button class="confirm-btn" id="load-confirm">Load</button>
      </div>
    </div>
  </div>
  
  <!-- Share Modal -->
  <div class="modal-container" id="share-modal-container">
    <div class="modal">
      <h2>Share Script</h2>
      <input type="text" id="share-link" readonly placeholder="Share link will appear here">
      <div class="modal-buttons">
        <button class="cancel-btn" id="share-cancel">Close</button>
        <button class="confirm-btn" id="copy-link">Copy Link</button>
      </div>
    </div>
  </div>
  
  <!-- Format Options Modal (dynamic) -->

  <script>
    // Arabic translations
    const arabicLabels = {
      'SCENE HEADING': 'العنوان الرئيسي',
      'ACTION': 'الفعل',
      'CHARACTER': 'الشخصية',
      'DIALOGUE': 'الحوار',
      'PARENTHETICAL': 'توضيح',
      'TRANSITION': 'الانتقال',
      'SAVE': 'حفظ',
      'LOAD': 'تحميل',
      'EXPORT': 'تصدير',
      'FEEDBACK': 'تعليق',
      'ARABIC': 'English',
      'ENGLISH': 'عربي',
      'LIGHT': 'مضيء',
      'DARK': 'مظلم',
      'SHARE': 'مشاركة'
    };

    // Global state
    let currentElement = 'scene-heading';
    let isRtlMode = false;
    let scriptCharacters = new Set(['ALEX', 'BARISTA']);
    let commonTransitions = [
      'CUT TO:',
      'FADE IN:',
      'FADE OUT:',
      'FADE TO BLACK',
      'DISSOLVE TO:',
      'SMASH CUT TO:',
      'JUMP CUT TO:',
      'MATCH CUT TO:',
      'IRIS IN:',
      'IRIS OUT:',
      'WIPE TO:',
      'CROSSFADE:',
      'FLASH CUT TO:',
      'INTERCUT WITH:',
      'FREEZE FRAME.',
      'THE END'
    ];

    // DOM references
    let editor, notification;

    // Initialize the editor
    document.addEventListener('DOMContentLoaded', function() {
      // Get DOM elements
      editor = document.getElementById('editor');
      notification = document.getElementById('notification');
      
      // Set up event listeners
      setupListeners();
      
      // Extract characters from existing content
      extractCharacters();
      
      // Find active element
      const activeElement = document.querySelector('.element');
      if (activeElement) {
        makeElementActive(activeElement);
      }
    });

    function setupListeners() {
      // Element type buttons
      document.querySelectorAll('.element-button').forEach(btn => {
        btn.addEventListener('click', function() {
          // Set active element type
          currentElement = this.dataset.type;
          
          // Update active button styling
          document.querySelectorAll('.element-button').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
          
          // Insert new element
          addNewElement(currentElement);
        });
      });
      
      // Action buttons
      document.getElementById('save-btn').addEventListener('click', showSaveOptions);
      document.getElementById('load-btn').addEventListener('click', showLoadOptions);
      document.getElementById('export-btn').addEventListener('click', showExportOptions);
      document.getElementById('theme-toggle').addEventListener('click', toggleTheme);
      document.getElementById('rtl-toggle').addEventListener('click', toggleDirection);
      document.getElementById('feedback-btn').addEventListener('click', toggleFeedback);
      document.getElementById('share-btn').addEventListener('click', shareScript);
      
      // Modal buttons
      document.getElementById('save-cancel')?.addEventListener('click', () => {
        document.getElementById('save-modal-container').style.display = 'none';
      });
      document.getElementById('save-confirm')?.addEventListener('click', () => {
        const title = document.getElementById('script-title').value.trim() || 'Untitled Script';
        const content = editor.innerHTML;
        
        // Save to localStorage
        const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
        scripts[title] = {
          content,
          characters: Array.from(scriptCharacters),
          timestamp: Date.now()
        };
        localStorage.setItem('scripts', JSON.stringify(scripts));
        
        // Hide modal and show notification
        document.getElementById('save-modal-container').style.display = 'none';
        showNotification(`Script "${title}" saved successfully`);
      });
      
      document.getElementById('load-cancel')?.addEventListener('click', () => {
        document.getElementById('load-modal-container').style.display = 'none';
      });
      document.getElementById('load-confirm')?.addEventListener('click', () => {
        const selected = document.querySelector('.saved-script-item.selected');
        if (!selected) {
          showNotification('Please select a script to load');
          return;
        }
        
        const scriptName = selected.getAttribute('data-name');
        const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
        
        if (scripts[scriptName]) {
          // Create a temporary div to safely parse the content
          const tempDiv = document.createElement('div');
          // Use DOMParser instead of innerHTML for safer parsing
          const parser = new DOMParser();
          const doc = parser.parseFromString(scripts[scriptName].content, 'text/html');
          tempDiv.append(...doc.body.childNodes);
          
          // Only copy the elements we expect in our screenplay editor
          const safeContent = document.createDocumentFragment();
          tempDiv.querySelectorAll('.element').forEach(element => {
            // Only copy expected attributes to prevent script injection
            const safeElement = document.createElement('div');
            safeElement.className = element.className;
            safeElement.id = element.id;
            safeElement.textContent = element.textContent; // Use textContent instead of innerHTML
            
            if (isRtlMode) {
              safeElement.setAttribute('dir', 'rtl');
              safeElement.setAttribute('lang', 'ar');
            }
            
            safeContent.appendChild(safeElement);
          });
          
          // Clear the editor and append the sanitized content
          editor.innerHTML = '';
          editor.appendChild(safeContent);
          
          // Restore characters
          if (scripts[scriptName].characters) {
            scriptCharacters = new Set(scripts[scriptName].characters);
          }
          
          document.getElementById('load-modal-container').style.display = 'none';
          showNotification(`Script "${scriptName}" loaded successfully`);
        }
      });
      
      document.getElementById('share-cancel')?.addEventListener('click', () => {
        document.getElementById('share-modal-container').style.display = 'none';
      });
      document.getElementById('copy-link')?.addEventListener('click', () => {
        const link = document.getElementById('share-link');
        link.select();
        document.execCommand('copy');
        showNotification('Link copied to clipboard');
      });
      
      document.getElementById('send-feedback-btn')?.addEventListener('click', () => {
        const feedbackText = document.getElementById('feedback-text')?.value.trim();
        if (!feedbackText) {
          showNotification('Please enter your feedback');
          return;
        }
        
        // In a real app, this would send feedback to a server
        showNotification('Thank you for your feedback!');
        if (document.getElementById('feedback-text')) {
          document.getElementById('feedback-text').value = '';
        }
        document.getElementById('feedback-box').style.display = 'none';
      });
      
      // Editor events
      if (editor) {
        // Handle Enter key to add new elements
        editor.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleEnterKey();
          } else if (e.key === 'Tab') {
            e.preventDefault();
            cycleElementType();
          }
        });
        
        // Handle clicks to set active element
        editor.addEventListener('click', function(e) {
          const target = e.target;
          if (target === editor) return;
          
          // Find closest screenplay element
          let element = target;
          while (element && element !== editor && !element.classList.contains('element')) {
            element = element.parentNode;
          }
          
          if (element && element !== editor) {
            makeElementActive(element);
          }
        });

        // Handle input event for character autocomplete
        editor.addEventListener('input', function(e) {
          const target = e.target;
          if (target === editor) return;
          
          // Find closest screenplay element
          let element = target;
          while (element && element !== editor && !element.classList.contains('element')) {
            element = element.parentNode;
          }
          
          if (element && element !== editor) {
            const elementClass = element.className.split(' ')[1];
            
            // Auto-uppercase for scene heading, character, and transition
            if (elementClass === 'scene-heading' || elementClass === 'character' || elementClass === 'transition') {
              const selection = window.getSelection();
              if (!selection || selection.rangeCount === 0) return;
              
              const range = selection.getRangeAt(0);
              const cursorPosition = range.startOffset;
              
              // Store the current text and cursor position
              const originalText = element.textContent || '';
              
              // Update to uppercase
              element.textContent = originalText.toUpperCase();
              
              // Restore cursor position
              setCaretPosition(element, cursorPosition);
            }
            
            // Show character suggestions
            if (elementClass === 'character') {
              const text = element.textContent?.trim().toUpperCase() || '';
              if (text.length > 0) {
                showCharacterSuggestions(text, element);
              } else {
                hideCharacterSuggestions();
              }
            }
          }
        });
      }
      
      // Close dropdowns and suggestions when clicking outside
      document.addEventListener('click', function(e) {
        if (!e.target.closest('#character-suggestions') && !e.target.closest('.character')) {
          hideCharacterSuggestions();
        }
        
        if (!e.target.closest('#transition-dropdown') && !e.target.closest('.transition')) {
          hideTransitionDropdown();
        }
      });
      
      // Set up transition dropdown items
      document.querySelectorAll('.transition-item').forEach(item => {
        item.addEventListener('click', function() {
          const activeElement = document.querySelector('.active-line');
          if (activeElement && activeElement.classList.contains('transition')) {
            activeElement.textContent = this.dataset.text;
            hideTransitionDropdown();
          }
        });
      });
    }

    // Make an element the active one
    function makeElementActive(element) {
      // Remove active class from all elements
      document.querySelectorAll('.element').forEach(el => {
        el.classList.remove('active-line');
      });
      
      // Add active class to clicked element
      element.classList.add('active-line');
      
      // Update current element type based on element class
      const elementClasses = element.className.split(' ');
      for (const cls of elementClasses) {
        if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
          currentElement = cls;
          break;
        }
      }
      
      // Update active button in toolbar
      updateActiveButton();
      
      // If it's a transition element, set up the dropdown on click
      if (element.classList.contains('transition')) {
        element.addEventListener('click', function() {
          showTransitionDropdown(this);
        });
      }
    }

    // Add a new screenplay element
    function addNewElement(type, text = '') {
      if (!editor) return;
      
      // Create new element
      const div = document.createElement('div');
      div.className = `element ${type}`;
      div.id = `element-${Date.now()}`;
      
      // Set RTL direction if needed
      if (isRtlMode) {
        div.setAttribute('dir', 'rtl');
        div.setAttribute('lang', 'ar');
      }
      
      // Default content for specific types
      if (type === 'scene-heading' && !text) {
        div.textContent = isRtlMode ? '.INT ' : 'INT. ';
      } else if (type === 'parenthetical' && !text) {
        div.textContent = '()';
      } else if (text) {
        div.textContent = text;
      } else {
        div.innerHTML = '&nbsp;';
      }
      
      // Find active element
      const activeElement = document.querySelector('.active-line');
      
      // Remove active line from all elements
      document.querySelectorAll('.element').forEach(el => {
        el.classList.remove('active-line');
      });
      
      // Add active line to new element
      div.classList.add('active-line');
      
      // Insert after active element or append to editor
      if (activeElement) {
        activeElement.after(div);
      } else {
        editor.appendChild(div);
      }
      
      // Set cursor position
      setCaretToEnd(div);
      
      // If it's a transition element, set up the dropdown on click
      if (type === 'transition') {
        div.addEventListener('click', function() {
          showTransitionDropdown(this);
        });
      }
      
      // Update current element
      currentElement = type;
      
      // Update active button
      updateActiveButton();
      
      return div;
    }

    // Handle Enter key presses
    function handleEnterKey() {
      const activeElement = document.querySelector('.active-line');
      if (!activeElement) return;
      
      // Get current type from class
      let type = null;
      const classes = activeElement.className.split(' ');
      for (const cls of classes) {
        if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
          type = cls;
          break;
        }
      }
      
      if (!type) return;
      
      // Determine next type based on screenplay format rules
      let nextType = 'action'; // Default
      
      if (type === 'scene-heading') nextType = 'action';
      else if (type === 'action') nextType = 'action';
      else if (type === 'character') {
        const text = activeElement.textContent.trim();
        if (text) {
          nextType = 'dialogue';
          // Add character to our list
          scriptCharacters.add(text);
        } else {
          nextType = 'character';
        }
      }
      else if (type === 'dialogue') nextType = 'character';
      else if (type === 'parenthetical') nextType = 'dialogue';
      else if (type === 'transition') {
        // Always create a scene heading after a transition
        nextType = 'scene-heading';
      }
      
      // Create new element
      addNewElement(nextType);
      
      // Update current element type
      currentElement = nextType;
      
      // Update button styles
      updateActiveButton();
    }

    // Cycle through element types with Tab key
    function cycleElementType() {
      const activeElement = document.querySelector('.active-line');
      if (!activeElement) return;
      
      // Get current type from class
      let type = null;
      const classes = activeElement.className.split(' ');
      for (const cls of classes) {
        if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
          type = cls;
          break;
        }
      }
      
      if (!type) return;
      
      // Determine next type
      let nextType = 'action';
      
      if (type === 'scene-heading') nextType = 'action';
      else if (type === 'action') nextType = 'character';
      else if (type === 'character') nextType = 'parenthetical';
      else if (type === 'parenthetical') nextType = 'dialogue';
      else if (type === 'dialogue') nextType = 'character';
      else if (type === 'transition') nextType = 'scene-heading';
      
      // Remove old type class
      activeElement.classList.remove(type);
      
      // Add new type class
      activeElement.classList.add(nextType);
      
      // Special formatting for specific types
      if (nextType === 'scene-heading' && (activeElement.textContent.trim() === '' || activeElement.textContent === '\u00A0')) {
        activeElement.textContent = isRtlMode ? '.INT ' : 'INT. ';
      } else if (nextType === 'parenthetical' && (activeElement.textContent.trim() === '' || activeElement.textContent === '\u00A0')) {
        activeElement.textContent = '()';
      }
      
      // Update current element type
      currentElement = nextType;
      
      // Update button styles
      updateActiveButton();
      
      // Set focus to the element
      setCaretToEnd(activeElement);
    }

    // Update active button in toolbar
    function updateActiveButton() {
      document.querySelectorAll('.element-button').forEach(btn => {
        btn.classList.remove('active');
      });
      
      const activeButton = document.querySelector(`.element-button[data-type="${currentElement}"]`);
      if (activeButton) {
        activeButton.classList.add('active');
      }
    }

    // Place cursor at the end of an element
    function setCaretToEnd(el) {
      if (!el) return;
      
      el.focus();
      const range = document.createRange();
      if (el.firstChild) {
        range.setStart(el.firstChild, el.firstChild.textContent.length);
      } else {
        range.setStart(el, 0);
      }
      range.collapse(true);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }
    
    // Set caret position within an element
    function setCaretPosition(element, position) {
      if (!element) return;
      
      // Make sure element has content
      if (!element.firstChild) {
        element.textContent = ' ';
      }
      
      const range = document.createRange();
      const selection = window.getSelection();
      
      // Ensure position is valid
      const maxLength = element.firstChild.textContent.length;
      position = Math.min(Math.max(0, position), maxLength);
      
      range.setStart(element.firstChild, position);
      range.collapse(true);
      
      selection.removeAllRanges();
      selection.addRange(range);
    }

    // Extract character names from elements
    function extractCharacters() {
      if (!editor) return;
      
      const characterElements = editor.querySelectorAll('.character');
      characterElements.forEach(el => {
        const character = el.textContent?.trim();
        if (character) {
          scriptCharacters.add(character);
        }
      });
    }

    // Show character suggestions dropdown
    function showCharacterSuggestions(text, element) {
      if (!text) return;
      
      const characterSuggestions = document.getElementById('character-suggestions');
      if (!characterSuggestions) return;
      
      // Get matching characters
      const matches = Array.from(scriptCharacters).filter(char => 
        char.includes(text) && char !== text
      );
      
      if (matches.length > 0) {
        // Clear previous suggestions
        characterSuggestions.innerHTML = '';
        
        // Position the dropdown
        const rect = element.getBoundingClientRect();
        characterSuggestions.style.top = `${rect.bottom + window.scrollY}px`;
        characterSuggestions.style.left = `${rect.left + window.scrollX}px`;
        characterSuggestions.style.display = 'block';
        
        // Add suggestion items
        matches.forEach(char => {
          const item = document.createElement('div');
          item.className = 'character-suggestion-item';
          item.textContent = char;
          item.addEventListener('click', () => {
            element.textContent = char;
            hideCharacterSuggestions();
            
            // After selecting a character, create a dialogue element
            const nextElement = document.querySelector('.element.dialogue');
            if (!nextElement) {
              addNewElement('dialogue');
            } else {
              makeElementActive(nextElement);
            }
          });
          characterSuggestions.appendChild(item);
        });
      } else {
        hideCharacterSuggestions();
      }
    }

    // Hide character suggestions
    function hideCharacterSuggestions() {
      const characterSuggestions = document.getElementById('character-suggestions');
      if (characterSuggestions) {
        characterSuggestions.style.display = 'none';
      }
    }

    // Show transition dropdown
    function showTransitionDropdown(element) {
      const dropdown = document.getElementById('transition-dropdown');
      if (!dropdown) return;
      
      const rect = element.getBoundingClientRect();
      dropdown.style.top = `${rect.bottom + window.scrollY}px`;
      dropdown.style.left = `${rect.left + window.scrollX}px`;
      dropdown.style.display = 'block';
    }

    // Hide transition dropdown
    function hideTransitionDropdown() {
      const dropdown = document.getElementById('transition-dropdown');
      if (dropdown) {
        dropdown.style.display = 'none';
      }
    }

    // Show save options
    function showSaveOptions() {
      // Create modal for save options
      const modal = document.createElement('div');
      modal.className = 'modal-container';
      modal.style.display = 'flex';
      
      const modalContent = document.createElement('div');
      modalContent.className = 'modal';
      
      const title = document.createElement('h2');
      title.textContent = 'Save Script';
      
      const subtitle = document.createElement('p');
      subtitle.textContent = 'Choose save format:';
      
      // Create options
      const optionsContainer = document.createElement('div');
      
      // Option 1: Save to Browser
      const browserOption = document.createElement('div');
      browserOption.className = 'format-option';
      const browserTitle = document.createElement('h3');
      browserTitle.textContent = 'Save to Browser';
      const browserDesc = document.createElement('p');
      browserDesc.textContent = 'Save your screenplay in this browser for later editing.';
      browserOption.appendChild(browserTitle);
      browserOption.appendChild(browserDesc);
      
      // Option 2: Final Draft
      const fdxOption = document.createElement('div');
      fdxOption.className = 'format-option';
      const fdxTitle = document.createElement('h3');
      fdxTitle.textContent = 'Download as Final Draft (FDX)';
      const fdxDesc = document.createElement('p');
      fdxDesc.textContent = 'Export in FDX format for use with Final Draft software.';
      fdxOption.appendChild(fdxTitle);
      fdxOption.appendChild(fdxDesc);
      
      // Option 3: JSON
      const jsonOption = document.createElement('div');
      jsonOption.className = 'format-option';
      const jsonTitle = document.createElement('h3');
      jsonTitle.textContent = 'Download as JSON';
      const jsonDesc = document.createElement('p');
      jsonDesc.textContent = 'Save as a structured JSON file that can be loaded back later.';
      jsonOption.appendChild(jsonTitle);
      jsonOption.appendChild(jsonDesc);
      
      // Add options to container
      optionsContainer.appendChild(browserOption);
      optionsContainer.appendChild(fdxOption);
      optionsContainer.appendChild(jsonOption);
      
      // Cancel button
      const cancelButton = document.createElement('button');
      cancelButton.className = 'cancel-btn';
      cancelButton.textContent = 'Cancel';
      cancelButton.style.width = '100%';
      cancelButton.style.marginTop = '20px';
      
      // Add everything to modal
      modalContent.appendChild(title);
      modalContent.appendChild(subtitle);
      modalContent.appendChild(optionsContainer);
      modalContent.appendChild(cancelButton);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Add event listeners
      browserOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        saveToLocal();
      });
      
      fdxOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        exportAsFdx();
      });
      
      jsonOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        saveAsJson();
      });
      
      cancelButton.addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }
    
    // Show load options
    function showLoadOptions() {
      // Create modal for load options
      const modal = document.createElement('div');
      modal.className = 'modal-container';
      modal.style.display = 'flex';
      
      const modalContent = document.createElement('div');
      modalContent.className = 'modal';
      
      const title = document.createElement('h2');
      title.textContent = 'Load Script';
      
      const subtitle = document.createElement('p');
      subtitle.textContent = 'Choose load source:';
      
      // Create options
      const optionsContainer = document.createElement('div');
      
      // Option 1: Load from Browser
      const browserOption = document.createElement('div');
      browserOption.className = 'format-option';
      const browserTitle = document.createElement('h3');
      browserTitle.textContent = 'Load from Browser Storage';
      const browserDesc = document.createElement('p');
      browserDesc.textContent = 'Load a screenplay saved in this browser.';
      browserOption.appendChild(browserTitle);
      browserOption.appendChild(browserDesc);
      
      // Option 2: Upload File
      const fileOption = document.createElement('div');
      fileOption.className = 'format-option';
      const fileTitle = document.createElement('h3');
      fileTitle.textContent = 'Upload Script File';
      const fileDesc = document.createElement('p');
      fileDesc.textContent = 'Upload a screenplay file (FDX, JSON, or TXT).';
      fileOption.appendChild(fileTitle);
      fileOption.appendChild(fileDesc);
      
      // Add options to container
      optionsContainer.appendChild(browserOption);
      optionsContainer.appendChild(fileOption);
      
      // Cancel button
      const cancelButton = document.createElement('button');
      cancelButton.className = 'cancel-btn';
      cancelButton.textContent = 'Cancel';
      cancelButton.style.width = '100%';
      cancelButton.style.marginTop = '20px';
      
      // Add everything to modal
      modalContent.appendChild(title);
      modalContent.appendChild(subtitle);
      modalContent.appendChild(optionsContainer);
      modalContent.appendChild(cancelButton);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Add event listeners
      browserOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        loadFromLocal();
      });
      
      fileOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        loadFromFile();
      });
      
      cancelButton.addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }
    
    // Show export options
    function showExportOptions() {
      // Create modal for export options
      const modal = document.createElement('div');
      modal.className = 'modal-container';
      modal.style.display = 'flex';
      
      const modalContent = document.createElement('div');
      modalContent.className = 'modal';
      
      const title = document.createElement('h2');
      title.textContent = 'Export Script';
      
      const subtitle = document.createElement('p');
      subtitle.textContent = 'Choose export format:';
      
      // Create options
      const optionsContainer = document.createElement('div');
      
      // Option 1: FDX
      const fdxOption = document.createElement('div');
      fdxOption.className = 'format-option';
      const fdxTitle = document.createElement('h3');
      fdxTitle.textContent = 'Final Draft (FDX)';
      const fdxDesc = document.createElement('p');
      fdxDesc.textContent = 'Industry standard format for professional screenplay software.';
      fdxOption.appendChild(fdxTitle);
      fdxOption.appendChild(fdxDesc);
      
      // Option 2: PDF
      const pdfOption = document.createElement('div');
      pdfOption.className = 'format-option';
      const pdfTitle = document.createElement('h3');
      pdfTitle.textContent = 'PDF Document';
      const pdfDesc = document.createElement('p');
      pdfDesc.textContent = 'Professional looking PDF with proper screenplay formatting.';
      pdfOption.appendChild(pdfTitle);
      pdfOption.appendChild(pdfDesc);
      
      // Option 3: TXT
      const txtOption = document.createElement('div');
      txtOption.className = 'format-option';
      const txtTitle = document.createElement('h3');
      txtTitle.textContent = 'Plain Text (TXT)';
      const txtDesc = document.createElement('p');
      txtDesc.textContent = 'Simple text format readable by any text editor.';
      txtOption.appendChild(txtTitle);
      txtOption.appendChild(txtDesc);
      
      // Add options to container
      optionsContainer.appendChild(fdxOption);
      optionsContainer.appendChild(pdfOption);
      optionsContainer.appendChild(txtOption);
      
      // Cancel button
      const cancelButton = document.createElement('button');
      cancelButton.className = 'cancel-btn';
      cancelButton.textContent = 'Cancel';
      cancelButton.style.width = '100%';
      cancelButton.style.marginTop = '20px';
      
      // Add everything to modal
      modalContent.appendChild(title);
      modalContent.appendChild(subtitle);
      modalContent.appendChild(optionsContainer);
      modalContent.appendChild(cancelButton);
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Add event listeners
      fdxOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        exportAsFdx();
      });
      
      pdfOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        exportAsPdf();
      });
      
      txtOption.addEventListener('click', () => {
        document.body.removeChild(modal);
        exportAsTxt();
      });
      
      cancelButton.addEventListener('click', () => {
        document.body.removeChild(modal);
      });
    }

    // Save to browser's localStorage
    function saveToLocal() {
      const saveModal = document.getElementById('save-modal-container');
      if (saveModal) {
        saveModal.style.display = 'flex';
        const scriptTitle = document.getElementById('script-title');
        if (scriptTitle) {
          scriptTitle.value = '';
          scriptTitle.focus();
        }
      }
    }
    
    // Save as JSON file
    function saveAsJson() {
      // Get script title and filename
      const title = prompt('Enter a title for your script:', 'My Screenplay') || 'My Screenplay';
      const fileName = prompt('Enter a file name:', 'screenplay.json') || 'screenplay.json';
      
      // Create JSON structure
      const elements = document.querySelectorAll('#editor .element');
      const scriptData = {
        title: title,
        lastModified: new Date().toISOString(),
        characters: Array.from(scriptCharacters),
        elements: []
      };
      
      // Add elements to JSON
      elements.forEach(el => {
        const classes = el.className.split(' ');
        let type = null;
        for (const cls of classes) {
          if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
            type = cls;
            break;
          }
        }
        
        if (!type) return;
        
        const text = el.textContent.trim();
        if (!text) return;
        
        scriptData.elements.push({
          type: type,
          text: text,
          id: el.id || `element-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
        });
      });
      
      // Create and download JSON file
      const blob = new Blob([JSON.stringify(scriptData, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName.endsWith('.json') ? fileName : fileName + '.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Script saved as JSON successfully!');
    }
    
    // Load from browser's localStorage
    function loadFromLocal() {
      const loadModal = document.getElementById('load-modal-container');
      const scriptsList = document.getElementById('saved-scripts-list');
      
      if (loadModal && scriptsList) {
        // Clear previous list
        scriptsList.innerHTML = '';
        
        // Get saved scripts
        const scripts = JSON.parse(localStorage.getItem('scripts') || '{}');
        
        if (Object.keys(scripts).length === 0) {
          scriptsList.innerHTML = '<div style="padding: 10px;">No saved scripts found</div>';
        } else {
          // Sort by date (newest first)
          const sortedScripts = Object.entries(scripts).sort((a, b) => b[1].timestamp - a[1].timestamp);
          
          // Create list items
          sortedScripts.forEach(([name, data]) => {
            const item = document.createElement('div');
            item.className = 'saved-script-item';
            item.setAttribute('data-name', name);
            // Create elements instead of using innerHTML to prevent XSS
            const nameElement = document.createElement('strong');
            nameElement.textContent = name;
            
            const dateElement = document.createElement('small');
            dateElement.textContent = new Date(data.timestamp).toLocaleString();
            
            // Clear and append the new elements
            item.appendChild(nameElement);
            item.appendChild(document.createElement('br'));
            item.appendChild(dateElement);
            item.style.padding = '8px';
            item.style.margin = '5px 0';
            item.style.cursor = 'pointer';
            item.style.borderBottom = '1px solid rgba(255, 255, 255, 0.1)';
            
            // Select on click
            item.addEventListener('click', function() {
              document.querySelectorAll('.saved-script-item').forEach(el => {
                el.classList.remove('selected');
                el.style.backgroundColor = '';
              });
              this.classList.add('selected');
              this.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
            });
            
            scriptsList.appendChild(item);
          });
        }
        
        // Show modal
        loadModal.style.display = 'flex';
      }
    }
    
    // Load from file upload
    function loadFromFile() {
      // Create file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.json,.fdx,.txt';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);
      
      // Trigger file selection
      fileInput.click();
      
      // Handle file selection
      fileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
          const file = this.files[0];
          const reader = new FileReader();
          
          reader.onload = function(e) {
            try {
              const fileExt = file.name.split('.').pop().toLowerCase();
              
              if (fileExt === 'json') {
                // Parse JSON file
                const scriptData = JSON.parse(e.target.result);
                loadJsonScript(scriptData);
              } else if (fileExt === 'fdx') {
                // Parse FDX file
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(e.target.result, 'text/xml');
                loadFdxScript(xmlDoc);
              } else if (fileExt === 'txt') {
                // Parse plain text
                loadTextScript(e.target.result);
              } else {
                showNotification('Unsupported file format');
              }
            } catch (error) {
              console.error('Error loading file:', error);
              showNotification('Error loading file: ' + error.message);
            }
          };
          
          // Read file as text
          if (file.name.endsWith('.json')) {
            reader.readAsText(file);
          } else if (file.name.endsWith('.fdx')) {
            reader.readAsText(file);
          } else if (file.name.endsWith('.txt')) {
            reader.readAsText(file);
          } else {
            showNotification('Unsupported file format');
          }
        }
        
        // Remove the file input
        document.body.removeChild(fileInput);
      });
    }
    
    // Load script from JSON format
    function loadJsonScript(scriptData) {
      try {
        // Clear editor
        editor.innerHTML = '';
        
        // Reset characters set
        scriptCharacters = new Set();
        if (scriptData.characters && Array.isArray(scriptData.characters)) {
          scriptData.characters.forEach(char => scriptCharacters.add(char));
        }
        
        // Add elements to editor
        if (scriptData.elements && Array.isArray(scriptData.elements)) {
          scriptData.elements.forEach(element => {
            if (!element.type || !element.text) return;
            
            const div = document.createElement('div');
            div.className = `element ${element.type}`;
            div.id = element.id || `element-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            div.textContent = element.text;
            
            if (isRtlMode) {
              div.setAttribute('dir', 'rtl');
              div.setAttribute('lang', 'ar');
            }
            
            editor.appendChild(div);
          });
        }
        
        // Set focus to first element
        const firstElement = editor.querySelector('.element');
        if (firstElement) {
          makeElementActive(firstElement);
        }
        
        showNotification(`Script "${scriptData.title || 'Untitled'}" loaded successfully!`);
      } catch (error) {
        console.error('Error loading JSON script:', error);
        showNotification('Error loading script: ' + error.message);
      }
    }
    
    // Load script from FDX format
    function loadFdxScript(xmlDoc) {
      try {
        // Clear editor
        editor.innerHTML = '';
        
        // Reset characters set
        scriptCharacters = new Set();
        
        // Extract paragraphs from FDX
        const paragraphs = xmlDoc.querySelectorAll('Paragraph');
        
        // Process each paragraph
        paragraphs.forEach(paragraph => {
          const type = paragraph.getAttribute('Type');
          const textElement = paragraph.querySelector('Text');
          if (!type || !textElement) return;
          
          const text = textElement.textContent.trim();
          if (!text) return;
          
          // Map FDX types to our types
          let elementType = '';
          switch (type) {
            case 'Scene Heading':
              elementType = 'scene-heading';
              break;
            case 'Action':
              elementType = 'action';
              break;
            case 'Character':
              elementType = 'character';
              scriptCharacters.add(text);
              break;
            case 'Parenthetical':
              elementType = 'parenthetical';
              break;
            case 'Dialogue':
              elementType = 'dialogue';
              break;
            case 'Transition':
              elementType = 'transition';
              break;
            default:
              elementType = 'action';
              break;
          }
          
          // Create element
          const div = document.createElement('div');
          div.className = `element ${elementType}`;
          div.id = `element-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          div.textContent = text;
          
          if (isRtlMode) {
            div.setAttribute('dir', 'rtl');
            div.setAttribute('lang', 'ar');
          }
          
          editor.appendChild(div);
        });
        
        // Set focus to first element
        const firstElement = editor.querySelector('.element');
        if (firstElement) {
          makeElementActive(firstElement);
        }
        
        // Try to get title
        let title = 'Untitled';
        const titleElement = xmlDoc.querySelector('Title');
        if (titleElement && titleElement.textContent) {
          title = titleElement.textContent.trim();
        }
        
        showNotification(`Script "${title}" loaded successfully!`);
      } catch (error) {
        console.error('Error loading FDX script:', error);
        showNotification('Error loading script: ' + error.message);
      }
    }
    
    // Load script from plain text
    function loadTextScript(text) {
      try {
        // Clear editor
        editor.innerHTML = '';
        
        // Reset characters set
        scriptCharacters = new Set();
        
        // Split text into lines
        const lines = text.split('\n');
        
        let currentType = 'scene-heading';
        let buffer = '';
        
        // Process each line
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          
          // Skip empty lines
          if (!line) {
            // Empty line might indicate end of current element
            if (buffer) {
              addElementFromText(currentType, buffer);
              buffer = '';
              
              // Determine next element type
              if (currentType === 'scene-heading') {
                currentType = 'action';
              } else if (currentType === 'transition') {
                currentType = 'scene-heading';
              } else if (currentType === 'dialogue') {
                currentType = 'character';
              }
            }
            continue;
          }
          
          // Try to determine element type from content
          if (line.toUpperCase() === line && line.includes('INT.') || line.includes('EXT.')) {
            // If we have buffered text, add it
            if (buffer) {
              addElementFromText(currentType, buffer);
            }
            
            // This is a scene heading
            currentType = 'scene-heading';
            buffer = line;
          } else if (line.toUpperCase() === line && line.endsWith('TO:')) {
            // If we have buffered text, add it
            if (buffer) {
              addElementFromText(currentType, buffer);
            }
            
            // This is a transition
            currentType = 'transition';
            buffer = line;
          } else if (line.toUpperCase() === line && !line.startsWith('(')) {
            // If we have buffered text, add it
            if (buffer) {
              addElementFromText(currentType, buffer);
            }
            
            // This is a character
            currentType = 'character';
            buffer = line;
            scriptCharacters.add(line);
          } else if (line.startsWith('(') && line.endsWith(')')) {
            // If we have buffered text, add it
            if (buffer) {
              addElementFromText(currentType, buffer);
            }
            
            // This is a parenthetical
            currentType = 'parenthetical';
            buffer = line;
          } else {
            // If we're coming from a character or parenthetical, this is dialogue
            if (currentType === 'character' || currentType === 'parenthetical') {
              // If we have buffered text, add it
              if (buffer) {
                addElementFromText(currentType, buffer);
              }
              
              currentType = 'dialogue';
              buffer = line;
            } else if (buffer) {
              // Append to current buffer with a space
              buffer += ' ' + line;
            } else {
              // Start new buffer
              buffer = line;
            }
          }
        }
        
        // Add any remaining buffered text
        if (buffer) {
          addElementFromText(currentType, buffer);
        }
        
        // Set focus to first element
        const firstElement = editor.querySelector('.element');
        if (firstElement) {
          makeElementActive(firstElement);
        }
        
        showNotification('Script loaded successfully!');
      } catch (error) {
        console.error('Error loading text script:', error);
        showNotification('Error loading script: ' + error.message);
      }
    }
    
    // Helper function to add element from text
    function addElementFromText(type, text) {
      const div = document.createElement('div');
      div.className = `element ${type}`;
      div.id = `element-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      div.textContent = text;
      
      if (isRtlMode) {
        div.setAttribute('dir', 'rtl');
        div.setAttribute('lang', 'ar');
      }
      
      editor.appendChild(div);
    }
    
    // Export as plain text
    function exportAsTxt() {
      // Create content for export
      let content = '';
      
      // Get all elements
      const elements = document.querySelectorAll('#editor .element');
      elements.forEach(el => {
        const classes = el.className.split(' ');
        let type = null;
        for (const cls of classes) {
          if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
            type = cls;
            break;
          }
        }
        
        if (!type) return;
        
        const text = el.textContent.trim();
        if (!text) return;
        
        // Format based on element type
        switch (type) {
          case 'scene-heading':
            content += text.toUpperCase() + '\n\n';
            break;
          case 'action':
            content += text + '\n\n';
            break;
          case 'character':
            content += text.toUpperCase() + '\n';
            break;
          case 'parenthetical':
            content += text + '\n';
            break;
          case 'dialogue':
            content += text + '\n\n';
            break;
          case 'transition':
            content += text.toUpperCase() + '\n\n';
            break;
        }
      });
      
      // Prompt for file name
      const fileName = prompt('Enter a file name for your script:', 'screenplay.txt') || 'screenplay.txt';
      
      // Create a download link
      const blob = new Blob([content], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName.endsWith('.txt') ? fileName : fileName + '.txt';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Script exported as TXT successfully!');
    }
    
    // Export as Final Draft FDX format
    function exportAsFdx() {
      // Get script title
      const title = prompt('Enter a title for your script:', 'My Screenplay') || 'My Screenplay';
      const fileName = prompt('Enter a file name:', 'screenplay.fdx') || 'screenplay.fdx';
      
      // Create FDX XML structure
      let fdxContent = `<?xml version="1.0" encoding="UTF-8"?>
<FinalDraft DocumentType="Script" Template="Screenplay" Version="3">
  <Content>
    <TitlePage>
      <Title>${escapeXml(title)}</Title>
      <Author>Fade Out Writer</Author>
      <Copyright>Copyright (c) ${new Date().getFullYear()}</Copyright>
    </TitlePage>
    <Paragraph Type="Action">
      <Text></Text>
    </Paragraph>`;
      
      // Get all elements and convert to FDX format
      const elements = document.querySelectorAll('#editor .element');
      elements.forEach(el => {
        const classes = el.className.split(' ');
        let type = null;
        for (const cls of classes) {
          if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
            type = cls;
            break;
          }
        }
        
        if (!type) return;
        
        const text = el.textContent.trim();
        if (!text) return;
        
        // Map our types to Final Draft types
        let fdxType = '';
        switch (type) {
          case 'scene-heading':
            fdxType = 'Scene Heading';
            break;
          case 'action':
            fdxType = 'Action';
            break;
          case 'character':
            fdxType = 'Character';
            break;
          case 'parenthetical':
            fdxType = 'Parenthetical';
            break;
          case 'dialogue':
            fdxType = 'Dialogue';
            break;
          case 'transition':
            fdxType = 'Transition';
            break;
        }
        
        // Add paragraph to FDX
        fdxContent += `
    <Paragraph Type="${fdxType}">
      <Text>${escapeXml(text)}</Text>
    </Paragraph>`;
      });
      
      // Close FDX structure
      fdxContent += `
  </Content>
</FinalDraft>`;
      
      // Create a download link
      const blob = new Blob([fdxContent], {type: 'application/xml'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName.endsWith('.fdx') ? fileName : fileName + '.fdx';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('Script exported as FDX successfully!');
    }
    
    // Export as PDF format
    function exportAsPdf() {
      const title = prompt('Enter a title for your script:', 'My Screenplay') || 'My Screenplay';
      const fileName = prompt('Enter a file name:', 'screenplay.pdf') || 'screenplay.pdf';
      
      // Create a styled HTML version for PDF conversion
      let htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <title>${escapeHtml(title)}</title>
  <style>
    @page {
      size: 8.5in 11in;
      margin: 1in;
    }
    body {
      font-family: Courier, monospace;
      font-size: 12pt;
      line-height: 1.2;
      margin: 0;
      padding: 0;
    }
    .title-page {
      height: 8.5in;
      position: relative;
      text-align: center;
      page-break-after: always;
    }
    .title {
      font-size: 24pt;
      text-align: center;
      position: absolute;
      top: 3.5in;
      width: 100%;
    }
    .author {
      position: absolute;
      bottom: 3in;
      width: 100%;
      text-align: center;
    }
    .copyright {
      position: absolute;
      bottom: 1in;
      width: 100%;
      text-align: center;
      font-size: 10pt;
    }
    .scene-heading {
      text-transform: uppercase;
      font-weight: bold;
      margin-top: 1.5em;
      margin-bottom: 1em;
    }
    .action {
      margin: 1em 0;
    }
    .character {
      text-transform: uppercase;
      margin-top: 1em;
      margin-bottom: 0.1em;
      margin-left: 2.2in;
    }
    .parenthetical {
      margin-left: 1.9in;
      margin-bottom: 0.1em;
    }
    .dialogue {
      width: 3.5in;
      margin-left: 1.5in;
      margin-bottom: 1em;
    }
    .transition {
      text-align: right;
      text-transform: uppercase;
      margin: 1em 0;
    }
  </style>
</head>
<body>
  <div class="title-page">
    <div class="title">${escapeHtml(title)}</div>
    <div class="author">Written by<br>Fade Out Writer</div>
    <div class="copyright">Copyright (c) ${new Date().getFullYear()}</div>
  </div>`;
      
      // Get all elements and convert to HTML
      const elements = document.querySelectorAll('#editor .element');
      elements.forEach(el => {
        const classes = el.className.split(' ');
        let type = null;
        for (const cls of classes) {
          if (['scene-heading', 'action', 'character', 'dialogue', 'parenthetical', 'transition'].includes(cls)) {
            type = cls;
            break;
          }
        }
        
        if (!type) return;
        
        const text = el.textContent.trim();
        if (!text) return;
        
        // Add element to HTML
        htmlContent += `
  <div class="${type}">${escapeHtml(text)}</div>`;
      });
      
      // Close HTML
      htmlContent += `
</body>
</html>`;
      
      // Create a new window for printing
      const printWindow = window.open('', '_blank');
      printWindow.document.write(htmlContent);
      printWindow.document.close();
      
      // Show instructions for saving as PDF
      const instructions = document.createElement('div');
      instructions.className = 'modal-container';
      instructions.style.display = 'flex';
      
      const instructionsContent = document.createElement('div');
      instructionsContent.className = 'modal';
      
      const instructionsTitle = document.createElement('h2');
      instructionsTitle.textContent = 'Save as PDF';
      
      const instructionsText = document.createElement('p');
      instructionsText.innerHTML = 'A new tab has opened with your formatted screenplay.<br><br>To save as PDF:<br>1. Press Ctrl+P (or Cmd+P on Mac)<br>2. Select "Save as PDF" in the printer options<br>3. Click Save';
      
      const okButton = document.createElement('button');
      okButton.className = 'confirm-btn';
      okButton.textContent = 'OK';
      okButton.style.width = '100%';
      okButton.style.marginTop = '20px';
      
      instructionsContent.appendChild(instructionsTitle);
      instructionsContent.appendChild(instructionsText);
      instructionsContent.appendChild(okButton);
      
      instructions.appendChild(instructionsContent);
      document.body.appendChild(instructions);
      
      // Handle ok button click
      okButton.addEventListener('click', () => {
        document.body.removeChild(instructions);
      });
      
      // Set timeout to trigger print dialog
      setTimeout(() => {
        printWindow.print();
      }, 1000);
      
      showNotification('Print dialog opened to save as PDF!');
    }
    
    // Helper function to escape XML
    function escapeXml(unsafe) {
      return unsafe.replace(/[<>&'"]/g, function (c) {
        switch (c) {
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '&': return '&amp;';
          case '\'': return '&apos;';
          case '"': return '&quot;';
        }
      });
    }
    
    // Helper function to escape HTML
    function escapeHtml(unsafe) {
      return unsafe.replace(/[&<>"']/g, function (c) {
        switch (c) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          case '\'': return '&#039;';
        }
      });
    }

    // Toggle theme
    function toggleTheme() {
      const themeToggle = document.getElementById('theme-toggle');
      const body = document.body;
      
      body.classList.toggle('light');
      
      if (body.classList.contains('light')) {
        themeToggle.textContent = isRtlMode ? arabicLabels['DARK'] : 'DARK';
      } else {
        themeToggle.textContent = isRtlMode ? arabicLabels['LIGHT'] : 'LIGHT';
      }
    }

    // Toggle direction (RTL for Arabic)
    function toggleDirection() {
      const dirToggle = document.getElementById('rtl-toggle');
      const elements = document.querySelectorAll('#editor .element');
      
      isRtlMode = !isRtlMode;
      
      if (isRtlMode) {
        // Switch to RTL
        editor.classList.add('rtl');
        editor.classList.remove('ltr');
        dirToggle.textContent = arabicLabels['ARABIC']; // "English" in Arabic
        
        // Update all elements
        elements.forEach(el => {
          el.setAttribute('dir', 'rtl');
          el.setAttribute('lang', 'ar');
        });
        
        // Update toolbar labels
        updateToolbarLabels(true);
      } else {
        // Switch to LTR
        editor.classList.remove('rtl');
        editor.classList.add('ltr');
        dirToggle.textContent = 'ARABIC';
        
        // Update all elements
        elements.forEach(el => {
          el.removeAttribute('dir');
          el.removeAttribute('lang');
        });
        
        // Update toolbar labels
        updateToolbarLabels(false);
      }
    }

    // Update toolbar labels based on language
    function updateToolbarLabels(useArabic) {
      if (useArabic) {
        document.querySelectorAll('.element-button').forEach(btn => {
          const type = btn.dataset.type;
          btn.textContent = arabicLabels[btn.textContent];
        });
        
        document.getElementById('save-btn').textContent = arabicLabels['SAVE'];
        document.getElementById('load-btn').textContent = arabicLabels['LOAD'];
        document.getElementById('export-btn').textContent = arabicLabels['EXPORT'];
        document.getElementById('feedback-btn').textContent = arabicLabels['FEEDBACK'];
        document.getElementById('share-btn').textContent = arabicLabels['SHARE'];
        
        // Toggle button needs special handling
        const themeToggle = document.getElementById('theme-toggle');
        themeToggle.textContent = document.body.classList.contains('light') ? arabicLabels['DARK'] : arabicLabels['LIGHT'];
      } else {
        document.querySelectorAll('.element-button').forEach(btn => {
          const type = btn.dataset.type;
          btn.textContent = type.replace('-', ' ').toUpperCase();
        });
        
        document.getElementById('save-btn').textContent = 'SAVE';
        document.getElementById('load-btn').textContent = 'LOAD';
        document.getElementById('export-btn').textContent = 'EXPORT';
        document.getElementById('feedback-btn').textContent = 'FEEDBACK';
        document.getElementById('share-btn').textContent = 'SHARE';
        
        // Toggle button needs special handling
        const themeToggle = document.getElementById('theme-toggle');
        themeToggle.textContent = document.body.classList.contains('light') ? 'DARK' : 'LIGHT';
      }
    }

    // Toggle feedback box
    function toggleFeedback() {
      const feedbackBox = document.getElementById('feedback-box');
      if (feedbackBox) {
        feedbackBox.style.display = feedbackBox.style.display === 'none' || !feedbackBox.style.display ? 'block' : 'none';
        if (feedbackBox.style.display === 'block') {
          document.getElementById('feedback-text').focus();
        }
      }
    }

    // Show notification
    function showNotification(message) {
      if (!notification) return;
      
      notification.textContent = message;
      notification.style.display = 'block';
      
      // Hide after 3 seconds
      setTimeout(() => {
        notification.style.display = 'none';
      }, 3000);
    }

    // Share script
    function shareScript() {
      const shareModal = document.getElementById('share-modal-container');
      const shareLink = document.getElementById('share-link');
      
      if (shareModal && shareLink) {
        // Generate a unique ID for the script
        const scriptId = Math.random().toString(36).substring(2, 15);
        
        // In a real app, this would save to a database and generate a real share URL
        // For this demo, we'll just create a fake URL
        const url = window.location.href.split('?')[0] + '?script=' + scriptId;
        
        shareLink.value = url;
        shareModal.style.display = 'flex';
      }
    }
  </script>
</body>
</html>
